## +
## ===================================================================
## Copyright(C) 2010 - 2014 Basefount Software Limited.
## and/or its licensors.  All rights reserved.
##
## The coded instructions, statements, computer programs, and/or
## related material (collectively the "Data") in these files contain
## unpublished information proprietary to Basefount Technology
## Limitd. ("Basefount") and/or its licensors, which is
## protected by Chinese copyright law and by international treaties.
##
## The Data is provided for use exclusively by You. You have the right 
## to use, modify, and incorporate this Data into other products for 
## purposes authorized by the Basefount software license agreement, 
## without fee.
##
## The copyright notices in the Software and this entire statement, 
## including the above license grant, this restriction and the 
## following disclaimer, must be included in all copies of the 
## Software, in whole or in part, and all derivative works of 
## the Software, unless such copies or derivative works are solely 
## in the form of machine-executable object code generated by a 
## source language processor.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
## BASEFOUNT DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR
## IMPLIED WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES
## OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
## PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
## TRADE PRACTICE. IN NO EVENT WILL BASEFOUNT AND/OR ITS LICENSORS 
## BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
## DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF BASEFOUNT 
## AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
## OR PROBABILITY OF SUCH DAMAGES.
##
## ===================================================================
## -

## +
## ===================================================================
##  Module Name: McdRenderFBXFunctions.py
##
##  Description:
##    Bake to maya joints with animation and geo can be export to
##  other program through FBX
##
## ===================================================================
## -

import maya.cmds as cmds
import maya.mel as mel
import pymel.core as pm
from McdGeneral import *
import os
import random
import re


# START OF RODEO HELPER FUNCTIONS

def rdoGetShadingEngine(mat):
    matNode = pm.PyNode(mat)
    return pm.listConnections(matNode, type='shadingEngine')[0]

def rdoGetObjectsWithMaterial(mat):
    shadingEngine = rdoGetShadingEngine(mat)
    return [node for node in pm.listConnections(shadingEngine, destination=True) if node.type() == 'transform']

def rdoSelectWithMaterial(mat):
    pm.select(rdoGetObjectsWithMaterial(mat))

def rdoAssignMaterialToObject(mat, obj):
    shadingEngine = rdoGetShadingEngine(mat)
    pm.sets(shadingEngine, edit=True, forceElement=obj)

# END OF RODEO HELPER FUNCTIONS


def McdGetGeoForRender(geoRoot, seed):
    # list child
    # find direct geo
    # find grp
        # for each grp
        # find direct geo
        # find grp
            # for each grp
                # select one
    chooseGeos = []
    nextRoots = []
                
    allChild = cmds.listRelatives(geoRoot, c = True, p = False, fullPath = True)
    if allChild == [] or allChild == None:
        return chooseGeos
        
    for i in range(len(allChild)):
        childNode = cmds.listRelatives(allChild[i], c = True, p = False, path = True)
        if childNode == [] or childNode == None:
            continue
        if cmds.nodeType(childNode[0]) == "mesh":
            if cmds.getAttr(childNode[0] + ".intermediateObject") != 1:
                chooseGeos.append(childNode[0])
        else:
            nextRoots.append(allChild[i])
            
    if nextRoots == []:
        return chooseGeos
            
    for i in range(len(nextRoots)):
        subNodes = cmds.listRelatives(nextRoots[i], c = True, p = False, path = True)
        if subNodes == [] or subNodes == None:
            continue
        
        # select random one in subNodes
        randNum = int(McdSolveASeedMinMax(seed+i, 11.457, 0, len(subNodes)))
        
        if subNodes[randNum].find("McdSubRoot_") >= 0:
            subChooseGeos = McdGetGeoForRender(subNodes[randNum], seed+i)
            chooseGeos.extend(subChooseGeos)
        else:
            allGeoRaw = cmds.listRelatives(subNodes[randNum], c = True, p = False, ad = True, path = True)
            if allGeoRaw == None or allGeoRaw == []:
                continue
            for j in range(len(allGeoRaw)):
                if cmds.nodeType(allGeoRaw[j]) == "mesh":
                    if cmds.getAttr(allGeoRaw[j] + ".intermediateObject") != 1:
                        chooseGeos.append(allGeoRaw[j])
        
    return chooseGeos

def McdSelectSameTypeChar():
    selObj = cmds.ls(sl = True)
    if MIsBlank(selObj):
        cmds.confirmDialog(t = "Error", m = "Please select a baked char bone.")
        return
    
    selBone = selObj[0]
    if cmds.nodeType(selBone) != "joint":
        cmds.confirmDialog(t = "Error", m = "Please select a baked char bone.")
        return
    
    # ikAxis
    try:
        tid = cmds.getAttr(selBone + ".atid")
    except:
        cmds.confirmDialog(t = "Error", m = "Please select a baked char bone.")
        return
    
    allBones = cmds.ls(type = "joint")
    
    print tid
    
    allChars = []
    for i in range(len(allBones)):
        try:
            tidGet = cmds.getAttr(allBones[i] + ".atid")
            if tid == tidGet:
                allChars.append(allBones[i])
        except:
            pass
        
        
    
    cmds.select(allChars, r = True)
    
    
    
    

def McdBakeAgentToAnimatedBone1(_0_all_1_sel_, dupGeo = True, useUI = True):
    
    # is set translate:
    globalNode = McdGetMcdGlobalNode()
    enableCache = cmds.getAttr(globalNode + ".enableCache")
    if enableCache == 0:
        if useUI:
            stat = cmds.confirmDialog(t = "Suggestion", m = "We suggest make agent cache before perform this.", b = ["Continue", "Canncel"])
            if stat == "Canncel":
                return;
        
    isSetTranslate = cmds.getAttr(globalNode + ".cacheTrans")
    isSetScale = cmds.getAttr(globalNode + ".cacheScale")
    
    allAgents = []
    fetchJointData = []
    if _0_all_1_sel_ == 0:
        allAgents = cmds.ls(type = "McdAgent")
    else:
        selObj = cmds.ls(sl = True)
        if selObj == [] or selObj == None:
            if useUI:
                cmds.confirmDialog(t = "Error", m = "Please select some agents.")
            return;
        cmds.select(hi = True)
        selObj2 = cmds.ls(sl = True)
        for i in range(len(selObj2)):
            if cmds.nodeType(selObj2[i]) == "McdAgent":
                allAgents.append(selObj2[i])
        
    
    if allAgents == [] or allAgents == None:
        if useUI:
            cmds.confirmDialog(t = "Error", m = "Please place your agents out and try again.")
        return;
    
    startFrame = cmds.playbackOptions(q = True, min = True)
    endFrame = cmds.playbackOptions(q = True, max = True)
    totalFrame = endFrame - startFrame + 1
    
    if useUI:
        stat = cmds.confirmDialog(t = "Save Confirm", m = "Please Save you scene before converting.\n" + \
                                                        "Are you want to bake you agents into Maya character\n" + \
                                                        "And keyframe them\n" + \
                                                        "Start Frame: " + str(int(startFrame)) + "\n" \
                                                        "End Frame: " + str(int(endFrame)), \
                                                    b = ["Yes", "No"])
        
        if stat != "Yes":
            return;
    
    # match conterpart (agentID) -> (original agent joint root)
    agentIDs = []
    allOAJoints = []
    allOAJointsDup = []
    allOAAllJoints = []
    allGeoRoots = []
    
    allAgentGroups = cmds.ls(type = "McdAgentGroup")
    for i in range(len(allAgentGroups)):
        allChildren = cmds.listRelatives(allAgentGroups[i], c = True, p = False, path = True)
        if allChildren != [] and allChildren != []:
            for j in range(len(allChildren)):
                if (allChildren[j].find("OriginalAgent_") >= 0):
                    allJoints = cmds.listRelatives(allChildren[j], c = True, p = False, path = True)
                    if allJoints != [] and allJoints != None:
                        agTid = cmds.getAttr(allAgentGroups[i] + ".tid")
                        agentIDs.append(agTid)
                        
                        if dupGeo:
                            # collect geo:
                            for c in range(len(allChildren)):
                                if (allChildren[c].find("Geometry_") >= 0):
                                    allGeoRoots.append(allChildren[c])
                        
                        for k in range(len(allJoints)):
                            if cmds.nodeType(allJoints[k]) == "joint":

                                allOAJoints.append(allJoints[k])
                                
                                cmds.select(allJoints[k], hi = True)
                                currentJoints = []
                                selObj = cmds.ls(sl = True, long = True)
                                if selObj != [] and selObj != None:
                                    for m in range(len(selObj)):
                                        if cmds.nodeType(selObj[m]) == "joint":
                                            currentJoints.append(selObj[m])
                                            
                                allOAAllJoints.append(currentJoints)
                                
                                break
    
    allNewRootBone = []
    
    autoKeyState = cmds.autoKeyframe( q = True, state = True)
    cmds.autoKeyframe( e = True, state = False)
    
    for f in range(int(totalFrame)):
        
        cmds.currentTime(startFrame + f)
        
        # init
        fetchJointData = []
        dataCounter = 0
        
        # fetch data all
        if _0_all_1_sel_ == 0:
            fetchJointData = mel.eval("McdAgentMatchCmd -mm 3")
        else:
            for i in range(len(allAgents)):
                cmds.select(allAgents[i])
                fetchJointData.extend(mel.eval("McdAgentMatchCmd -mm 4"))
                
        # deal with:
        if f == 0:
            # progress window
            totalCount = totalFrame
            if useUI:
                cmds.progressWindow( title = "Baking", progress = 0, \
                                   min = 0, \
                                   max = len(allAgents), \
                                   status = "Duplicating:", isInterruptable = True )
                
            
            for i in range(len(allOAJoints)):
                allOAJointsDup.append("")
                
            
            for i in range(len(allAgents)):   
                
                aid = cmds.getAttr(allAgents[i] + ".agentId")
                stri = str(aid)
                
                # progress
                if useUI:
                    if cmds.progressWindow( query = True, isCancelled = True ):
                        break
                
                agentTid = cmds.getAttr(allAgents[i] + ".tid")
                contentIndex = McdIndexOf(agentTid, agentIDs)
                
                if contentIndex == -1:
                    continue;
                
                if useUI:
                    # get Original Agent Joint Root---------------------------------
                    cmds.progressWindow( edit = True, progress = i)
                
                if allOAJointsDup[contentIndex] == "":
                    newBone = cmds.duplicate(allOAJoints[contentIndex], rr = True)
                    cmds.addAttr(newBone[0], ln = "atid", at = "long")
                    cmds.setAttr(newBone[0] + ".atid", agentTid)
                    
                    cmds.rename(newBone[0], newBone[0] + stri)
                    newBone[0] = newBone[0] + stri
                    allNewRootBone.append(newBone)
                    allOAJointsDup[contentIndex] = newBone;

                    # find <OAname> in first name
                    cmds.parent(newBone, w = True)
                    cmds.select(newBone, hi = True)
                    selObj = cmds.ls(sl = True, long = True)
                    if selObj != [] and selObj != None:
                        for j in range(len(selObj)):
                            invJ = len(selObj) - j - 1
                            if cmds.nodeType(selObj[invJ]) != "joint":
                                cmds.delete(selObj[invJ])
                    
                    selObj = cmds.ls(sl = True, long = True)
                    clearExtraAttribute(selObj)
                
                else:
                    newBone = cmds.duplicate(allOAJointsDup[contentIndex], rr = True)
                    allNewRootBone.append(newBone)
                    
                
            if useUI:
                cmds.progressWindow( endProgress=1 )
            
            # duplicate mesh and skinning:

            newRootNames = []
            for i in range(len(allAgents)):
                
                aid = cmds.getAttr(allAgents[i] + ".agentId")
                stri = str(aid)
                
                # --- rename ---------------------------------------------------
                oldName = allNewRootBone[i][0];
                cmds.select(oldName)
                suffixStr = "_Agent" + stri
                cmdStr = getRenameHiCmdStr_(suffixStr)
                mel.eval(cmdStr)
                
                newNameTemp = oldName + suffixStr
            
                digitCount = 0
                i = 0
                while (oldName[-1-i].isdigit()):
                    digitCount += 1
                    i += 1
                    
                end = len(oldName) - digitCount
                
                newNamePre = oldName[0:end]
                newName = newNamePre + suffixStr
                
                cmds.rename(newNameTemp, newName)
                print newName
                
                newRootNames.append(newName)
                # --------------------------------------------------------------
                
            allNewRootBone = newRootNames
                
            if useUI:
                cmds.progressWindow( title = "Baking", progress = 0, \
                                   min = 0, \
                                   max = len(allAgents), \
                                   status = "Skinning:", isInterruptable = True )
                            
            for i in range(len(allAgents)):
                
                aid = cmds.getAttr(allAgents[i] + ".agentId")
                stri = str(aid)
                
                if useUI:
                    # progress
                    if cmds.progressWindow( query = True, isCancelled = True ):
                        break
                
                agentTid = cmds.getAttr(allAgents[i] + ".tid")
                contentIndex = McdIndexOf(agentTid, agentIDs)
                
                if dupGeo:
                    geoRoot = allGeoRoots[contentIndex]
                    allGeos = McdGetGeoForRender(geoRoot, i)
                    
                    if allGeos != []:
                        allGeoJnts = []
                        for j in range(len(allGeos)):
                            links = cmds.listHistory(allGeos[j], pdo=0, il=1)
                            skin = cmds.ls(links, typ="skinCluster")
                            try:
                                jnts = cmds.skinCluster(skin[0], q=1, inf=1)
                            except:
                                jnts = []
                            allGeoJnts.append(jnts)
                        
                        allDups = cmds.duplicate(allGeos, rr = True)
                    
                        for j in range(len(allDups)):
                            cmds.parent(allDups[j], w = True)
                            
                            cmds.rename(allDups[j], allDups[j] + "_" + stri)
                            
                            if allGeoJnts[j] == []:
                                continue
                        
                            newJnt= []
                    
                            for jnt in allGeoJnts[j]:
                                jnt = jnt.split(':')[-1]
                                newJnt.append(jnt + "_Agent" + stri)
                                
                            cmds.skinCluster(newJnt, allDups[j] + "_" + stri, ibp=1, ih=1, dr=4, tsb=1, mi=1, nw=1)
                            cmds.select(allGeos[j], allDups[j] + "_" + stri)
                            cmds.copySkinWeights(surfaceAssociation='closestPoint', influenceAssociation=['oneToOne','closestJoint', 'label'], noMirror=1)
                    
                if useUI:
                    cmds.progressWindow( edit = True, progress = i)
            
            if useUI:
                cmds.progressWindow( endProgress=1 )   
                
                
        # now we have <OAName>_allAgents[i] and <OAName> 2 objects, match and keyframe all
        # match agent i
                
        for i in range(len(allAgents)):
            
            # agent index and agent tid
            dataCounter += 2
            
            cmds.select(allNewRootBone[i], hi = True)
            selObj = cmds.ls(sl = True)
            
            agentTid = cmds.getAttr(allAgents[i] + ".tid")
            contentIndex = McdIndexOf(agentTid, agentIDs)
            
            if f == 0:
                if len(selObj) == len(allOAAllJoints[contentIndex]):
                    for j in range(len(selObj)):
                        
                        cmds.setAttr(selObj[j] + ".t", fetchJointData[dataCounter], fetchJointData[dataCounter+1], fetchJointData[dataCounter+2])
                        dataCounter += 3
                        
                        cmds.setAttr(selObj[j] + ".r", fetchJointData[dataCounter], fetchJointData[dataCounter+1], fetchJointData[dataCounter+2])
                        dataCounter += 3
                        
                        cmds.setAttr(selObj[j] + ".s", fetchJointData[dataCounter], fetchJointData[dataCounter+1], fetchJointData[dataCounter+2])
                        dataCounter += 3
                        
                        # skip the custom attr:
                        nbData = fetchJointData[dataCounter]
                        dataCounter += 1 + int(nbData)
                        
                        if j == 0 or isSetTranslate:
                            nbKey = cmds.setKeyframe(selObj[j], at = "t")
                        
                    # setup "t", "s", keyframe "r"
                    nbKey = cmds.setKeyframe(at = "r")
                        
            else:
                if len(selObj) == len(allOAAllJoints[contentIndex]):
                    
                    for j in range(len(selObj)):
                        
                        if j == 0 or isSetTranslate:
                            cmds.setAttr(selObj[j] + ".t", fetchJointData[dataCounter], fetchJointData[dataCounter+1], fetchJointData[dataCounter+2])
                        dataCounter += 3
                        
                        cmds.setAttr(selObj[j] + ".r", fetchJointData[dataCounter], fetchJointData[dataCounter+1], fetchJointData[dataCounter+2])
                        dataCounter += 3
                        
                        if j == 0 or isSetScale:
                            cmds.setAttr(selObj[j] + ".s", fetchJointData[dataCounter], fetchJointData[dataCounter+1], fetchJointData[dataCounter+2])
                        dataCounter += 3
                        
                        # skip the custom attr:
                        nbData = fetchJointData[dataCounter]
                        dataCounter += 1 + int(nbData)
                        
                        if j == 0 or isSetTranslate:
                            nbKey = cmds.setKeyframe(selObj[j], at = "t")
                            
                        if j == 0 or isSetScale:
                            nbKey = cmds.setKeyframe(selObj[j], at = "s")
                        
                    # keyframe "r"
                    nbKey = cmds.setKeyframe(at = "r")
    
    cmds.autoKeyframe( e = True, state = autoKeyState)
    

def McdBakeAgentToAnimatedBone(_0_all_1_sel_):
    
    # is set translate:
    globalNode = McdGetMcdGlobalNode()
    enableCache = cmds.getAttr(globalNode + ".enableCache")
    if enableCache == 0:
        stat = cmds.confirmDialog(t = "Suggestion", m = "We suggest make agent cache before perform this.", b = ["Continue", "Canncel"])
        if stat == "Canncel":
            return;
        
    isSetTranslate = cmds.getAttr(globalNode + ".cacheTrans")
    
    allAgents = []
    fetchJointData = []
    if _0_all_1_sel_ == 0:
        allAgents = cmds.ls(type = "McdAgent")
    else:
        selObj = cmds.ls(sl = True)
        if selObj == [] or selObj == None:
            cmds.confirmDialog(t = "Error", m = "Please select some agents.")
            return;
        cmds.select(hi = True)
        selObj2 = cmds.ls(sl = True)
        for i in range(len(selObj2)):
            if cmds.nodeType(selObj2[i]) == "McdAgent":
                allAgents.append(selObj2[i])
        
    
    if allAgents == [] or allAgents == None:
        cmds.confirmDialog(t = "Error", m = "Please place your agents out and try again.")
        return;
    
    startFrame = cmds.playbackOptions(q = True, min = True)
    endFrame = cmds.playbackOptions(q = True, max = True)
    totalFrame = endFrame - startFrame + 1
    
    stat = cmds.confirmDialog(t = "Save Confirm", m = "Please Save you scene before converting.\n" + \
                                                    "Are you want to bake you agents into Maya character\n" + \
                                                    "And keyframe them\n" + \
                                                    "Start Frame: " + str(int(startFrame)) + "\n" \
                                                    "End Frame: " + str(int(endFrame)), \
                                                b = ["Yes", "No"])
    
    if stat != "Yes":
        return;
    
    # match conterpart (agentID) -> (original agent joint root)
    agentIDs = []
    allOAJoints = []
    allOAJointsDup = []
    allOAAllJoints = []
    allGeoRoots = []
    
    allAgentGroups = cmds.ls(type = "McdAgentGroup")
    for i in range(len(allAgentGroups)):
        allChildren = cmds.listRelatives(allAgentGroups[i], c = True, p = False, path = True)
        if allChildren != [] and allChildren != []:
            for j in range(len(allChildren)):
                if (allChildren[j].find("OriginalAgent_") >= 0):
                    allJoints = cmds.listRelatives(allChildren[j], c = True, p = False, path = True)
                    if allJoints != [] and allJoints != None:
                        agTid = cmds.getAttr(allAgentGroups[i] + ".tid")
                        agentIDs.append(agTid)
                        
                        # collect geo:
                        for c in range(len(allChildren)):
                            if (allChildren[c].find("Geometry_") >= 0):
                                allGeoRoots.append(allChildren[c])
                        
                        for k in range(len(allJoints)):
                            if cmds.nodeType(allJoints[k]) == "joint":

                                allOAJoints.append(allJoints[k])
                                
                                cmds.select(allJoints[k], hi = True)
                                currentJoints = []
                                selObj = cmds.ls(sl = True, long = True)
                                if selObj != [] and selObj != None:
                                    for m in range(len(selObj)):
                                        if cmds.nodeType(selObj[m]) == "joint":
                                            currentJoints.append(selObj[m])
                                            
                                allOAAllJoints.append(currentJoints)
                                
                                break
    
    allNewRootBone = []
    
    autoKeyState = cmds.autoKeyframe( q = True, state = True)
    cmds.autoKeyframe( e = True, state = False)
    
    for f in range(int(totalFrame)):
        
        cmds.currentTime(startFrame + f)
        
        # init
        fetchJointData = []
        dataCounter = 0
        
        # fetch data all
        if _0_all_1_sel_ == 0:
            fetchJointData = mel.eval("McdAgentMatchCmd -mm 3")
        else:
            for i in range(len(allAgents)):
                cmds.select(allAgents[i])
                fetchJointData.extend(mel.eval("McdAgentMatchCmd -mm 4"))
                
        # deal with:
        if f == 0:
            # progress window
            totalCount = totalFrame
            cmds.progressWindow( title = "Baking", progress = 0, \
                               min = 0, \
                               max = len(allAgents), \
                               status = "Duplicating:", isInterruptable = True )
            
            
            for i in range(len(allOAJoints)):
                allOAJointsDup.append("")
                
            
            for i in range(len(allAgents)):   
                
                stri = str(i)
                
                # progress
                if cmds.progressWindow( query = True, isCancelled = True ):
                    break
                
                agentTid = cmds.getAttr(allAgents[i] + ".tid")
                contentIndex = McdIndexOf(agentTid, agentIDs)
                
                if contentIndex == -1:
                    continue;
                
                # get Original Agent Joint Root---------------------------------
                cmds.progressWindow( edit = True, progress = i)
                
                if allOAJointsDup[contentIndex] == "":
                    newBone = cmds.duplicate(allOAJoints[contentIndex], rr = True)
                    cmds.rename(newBone[0], newBone[0] + stri)
                    newBone[0] = newBone[0] + stri
                    allNewRootBone.append(newBone)
                    allOAJointsDup[contentIndex] = newBone;

                    # find <OAname> in first name
                    cmds.parent(newBone, w = True)
                    cmds.select(newBone, hi = True)
                    selObj = cmds.ls(sl = True, long = True)
                    if selObj != [] and selObj != None:
                        for j in range(len(selObj)):
                            invJ = len(selObj) - j - 1
                            if cmds.nodeType(selObj[invJ]) != "joint":
                                cmds.delete(selObj[invJ])
                    
                    selObj = cmds.ls(sl = True, long = True)
                    clearExtraAttribute(selObj)
                
                else:
                    newBone = cmds.duplicate(allOAJointsDup[contentIndex], rr = True)
                    allNewRootBone.append(newBone)
                    
                
            cmds.progressWindow( endProgress=1 )
            
            # duplicate mesh and skinning:

            newRootNames = []
            for i in range(len(allAgents)):
                # --- rename ---------------------------------------------------
                oldName = allNewRootBone[i][0];
                cmds.select(oldName)
                suffixStr = "_Agent" + str(i)
                cmdStr = getRenameHiCmdStr_(suffixStr)
                mel.eval(cmdStr)
                
                newNameTemp = oldName + suffixStr
            
                digitCount = 0
                i = 0
                while (oldName[-1-i].isdigit()):
                    digitCount += 1
                    i += 1
                    
                end = len(oldName) - digitCount
                
                newNamePre = oldName[0:end]
                newName = newNamePre + suffixStr
                
                cmds.rename(newNameTemp, newName)
                
                newRootNames.append(newName)
                # --------------------------------------------------------------
                
            allNewRootBone = newRootNames
                
                
            cmds.progressWindow( title = "Baking", progress = 0, \
                               min = 0, \
                               max = len(allAgents), \
                               status = "Skinning:", isInterruptable = True )
                            
            for i in range(len(allAgents)):
                stri = str(i)
                
                # progress
                if cmds.progressWindow( query = True, isCancelled = True ):
                    break
                
                agentTid = cmds.getAttr(allAgents[i] + ".tid")
                contentIndex = McdIndexOf(agentTid, agentIDs)
                
                geoRoot = allGeoRoots[contentIndex]
                    
                cmds.progressWindow( edit = True, progress = i)
                    
            cmds.progressWindow( endProgress=1 )   
                
                
        # now we have <OAName>_allAgents[i] and <OAName> 2 objects, match and keyframe all
        # match agent i
                
        for i in range(len(allAgents)):
            
            # agent index and agent tid
            dataCounter += 2
            
            cmds.select(allNewRootBone[i], hi = True)
            selObj = cmds.ls(sl = True)
            
            agentTid = cmds.getAttr(allAgents[i] + ".tid")
            contentIndex = McdIndexOf(agentTid, agentIDs)
            
            if f == 0:
                if len(selObj) == len(allOAAllJoints[contentIndex]):
                    for j in range(len(selObj)):
                        
                        cmds.setAttr(selObj[j] + ".t", fetchJointData[dataCounter], fetchJointData[dataCounter+1], fetchJointData[dataCounter+2])
                        dataCounter += 3
                        
                        cmds.setAttr(selObj[j] + ".r", fetchJointData[dataCounter], fetchJointData[dataCounter+1], fetchJointData[dataCounter+2])
                        dataCounter += 3
                        
                        cmds.setAttr(selObj[j] + ".s", fetchJointData[dataCounter], fetchJointData[dataCounter+1], fetchJointData[dataCounter+2])
                        dataCounter += 3
                        
                        # skip the custom attr:
                        nbData = fetchJointData[dataCounter]
                        dataCounter += 1 + int(nbData)
                        
                        if j == 0 or isSetTranslate:
                            nbKey = cmds.setKeyframe(selObj[j], at = "t")
                        
                    # setup "t", "s", keyframe "r"
                    nbKey = cmds.setKeyframe(at = "r")
                        
            else:
                if len(selObj) == len(allOAAllJoints[contentIndex]):
                    
                    for j in range(len(selObj)):
                        
                        if j == 0 or isSetTranslate:
                            cmds.setAttr(selObj[j] + ".t", fetchJointData[dataCounter], fetchJointData[dataCounter+1], fetchJointData[dataCounter+2])
                        dataCounter += 3
                        
                        cmds.setAttr(selObj[j] + ".r", fetchJointData[dataCounter], fetchJointData[dataCounter+1], fetchJointData[dataCounter+2])
                        dataCounter += 6
                        
                        # skip the custom attr:
                        nbData = fetchJointData[dataCounter]
                        dataCounter += 1 + int(nbData)
                        
                        if j == 0 or isSetTranslate:
                            nbKey = cmds.setKeyframe(selObj[j], at = "t")
                        
                    # keyframe "r"
                    nbKey = cmds.setKeyframe(at = "r")
    
    cmds.autoKeyframe( e = True, state = autoKeyState)
        
    

def clearExtraAttribute(selObj):
    for i in range(len(selObj)):
        McdClearAttribute(selObj[i], "orgTranslate")
        McdClearAttribute(selObj[i], "orgRotate")
        McdClearAttribute(selObj[i], "orgScale")
        McdClearAttribute(selObj[i], "orgRotateOrder")
        McdClearAttribute(selObj[i], "shapeTranslate")
        McdClearAttribute(selObj[i], "shapeRotate")
        McdClearAttribute(selObj[i], "shapeScale")
        McdClearAttribute(selObj[i], "boneScaleMin")
        McdClearAttribute(selObj[i], "boneScaleMax")
        McdClearAttribute(selObj[i], "boneThicknessMin")
        McdClearAttribute(selObj[i], "boneThicknessMax")
        McdClearAttribute(selObj[i], "phyJointType")
        McdClearAttribute(selObj[i], "jointLocalMatrix")
        McdClearAttribute(selObj[i], "swingUp")
        McdClearAttribute(selObj[i], "swingDw")
        McdClearAttribute(selObj[i], "twistUp")
        McdClearAttribute(selObj[i], "twistDw")
            

def McdRandomizeTexturesDuplicate():
    # find all agent geo
    # find all shaders
    # for each shader:
    #     test is this can be randmize
    #     if can: find all obj relative with this shader
    #         duplicate shaders node based on number
    
    # find all agent geo -------------------------------------------------------
    allGeoGrp = cmds.ls("*Geometry_*")
    allGeoGrpRef = cmds.ls("*:Geometry_*")
    allGeoGrp.extend(allGeoGrpRef)
    if McdIsBlank(allGeoGrp):
        return
    allGeoGrpList = []
    for i in range(len(allGeoGrp)):
        geoGrpParent = cmds.listRelatives(allGeoGrp[i], p = True, c = False)
        if McdIsBlank(geoGrpParent):
            continue
        if cmds.nodeType(geoGrpParent[0]) == "McdAgentGroup":
            allGeoGrpList.append(allGeoGrp[i])
    
    allGeos = []
    for i in range(len(allGeoGrpList)):
        allSubNodes = cmds.listRelatives(allGeoGrpList[i], c = True, p = False, ad = True, path = True)
        if McdIsBlank(allSubNodes):
            continue
        for j in range(len(allSubNodes)):
            if cmds.nodeType(allSubNodes[j]) == "mesh":
                if not cmds.getAttr(allSubNodes[j] + ".intermediateObject"):
                    canAdd = True
                    try:
                        if cmds.getAttr(allSubNodes[j] + ".autoTex"):
                            canAdd = False
                    except:
                        pass
                    
                    # bypass the texture sequence ones
                    if canAdd:
                        allGeos.append(allSubNodes[j])
    if allGeos == []:
        return
    
    # find all shaders ---------------------------------------------------------
    allShdGrp = []
    for i in range(len(allGeos)):
        allConns = cmds.listConnections(allGeos[i], d = True, s = False)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if cmds.nodeType(allConns[j]) == "shadingEngine":
                if allConns[j] not in allShdGrp:
                    allShdGrp.append(allConns[j])
    if allShdGrp == []:
        return
    
    
    allShaders = []
    for i in range(len(allShdGrp)):
        allConns = cmds.listConnections(allShdGrp[i], s = True, d = False, p = True)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if allConns[j].find(".outColor") > 0:
                shaderName = allConns[j].split(".outColor")[0]
                if shaderName not in allShaders:
                    allShaders.append(shaderName)
            ############### v add v ###############
            elif allConns[j].find(".outValue") > 0:
                shaderName = allConns[j].split(".outValue")[0]
                if shaderName not in allShaders:
                    allShaders.append(shaderName)
            ############### ^ add ^ ###############

    if allShaders == []:
        return


    # for each shaders: --------------------------------------------------------
    baseNamePrePreRec = ""
    for i in range(len(allShaders)):
        # test is this can be randmize
        # find outColor node, "file" node --------------------------------------
        currentShader = allShaders[i]
        
        try:
            cmds.addAttr(currentShader, ln = "copy", at = "bool")
        except:
            pass
        
        allHis = cmds.listHistory(currentShader)
        if McdIsBlank(allHis):
            continue
        allFileNodes = []
        for j in range(len(allHis)):
            if cmds.nodeType(allHis[j]) == "file" or cmds.nodeType(allHis[j]) == "octaneImageTexture" or cmds.nodeType(allHis[j]) == "aiImage":
                allFileNodes.append(allHis[j])
        if allFileNodes == []:
            continue
        
        fileNodeColor = ""
        for j in range(len(allFileNodes)):
            if cmds.nodeType(allFileNodes[j]) == "file":
                texTemp = cmds.getAttr(allFileNodes[j] + ".fileTextureName")
            elif cmds.nodeType(allFileNodes[j]) == "octaneImageTexture":
                texTemp = cmds.getAttr(allFileNodes[j] + ".File")
            elif cmds.nodeType(allFileNodes[j]) == "aiImage":
                texTemp = cmds.getAttr(allFileNodes[j] + ".filename")
                
            texNew = udimSwapTest(texTemp)
            if texNew != None:
                udimSwap = True
                orgFileName = texTemp
                texTemp = texNew
                
            thdPart = texTemp.split("_")[-1]
            secPart = thdPart.split(".")[0]
            if secPart.isdigit():
                fileNodeColor = allFileNodes[j]
                break
        
        if fileNodeColor == "":
            continue


        # --- we have:
        # 1. fileNodeColor
        # 2. currentShader
        # find file path, and test randomizable? -------------------------------
        if cmds.nodeType(allFileNodes[j]) == "file":
            texMaster = cmds.getAttr(fileNodeColor + ".fileTextureName")
        elif cmds.nodeType(allFileNodes[j]) == "octaneImageTexture":
            texMaster = cmds.getAttr(fileNodeColor + ".File")
            # need transfer to abs path
            if not os.access(texMaster, os.R_OK):
                projectFolder = cmds.workspace( q = True, rd = True)
                texMaster = projectFolder + texMaster
        elif cmds.nodeType(allFileNodes[j]) == "aiImage":
            texMaster = cmds.getAttr(fileNodeColor + ".filename")
            
        texNew = udimSwapTest(texMaster)
        if texNew != None:
            udimSwap = True
            orgFileName = texMaster
            texMaster = texNew
            

        if texMaster == None:
            print "# # Miarmy Echo: texture path not set."
            continue
        if not os.access(texMaster, os.R_OK):
            print "# # Miarmy Echo: texture path not correct."
            continue
        ############### v delete1 v ###############
        '''#                                                            # d:/abc/bbb/kkk_ggg_0.jpg  (master)
        dirName = os.path.dirname(texMaster)                            # d:/abc/bbb                (dir)
        baseName = os.path.basename(texMaster)                          # kkk_ggg_0.jpg             (base)
            
        baseNameExt = baseName.split(".")[-1]                           # jpg                       (extension)
        baseNamePre = baseName.split("." + baseNameExt)[0]              # kkk_ggg_0                 (base pre)
        lastUS = baseNamePre.rfind("_")
        if lastUS <= 0:
            continue
        baseNamePrePre = baseNamePre[0 : lastUS]                        # kkk_ggg                   (base pre pre)
        baseNamePreIdStr = baseNamePre[lastUS+1 : len(baseNamePre)]     # 0                         (pre id)
        
        if not baseNamePreIdStr.isdigit():
            continue
        
        baseNamePreId = int(baseNamePreIdStr)
        baseNamePreIdStr = str(baseNamePreId)
        
        newPath = dirName + "/" + baseNamePrePre + "_" + baseNamePreIdStr + "." + baseNameExt
        if not os.access(newPath, os.R_OK):
            continue
        
        allPaths = []
        while(True):
            baseNamePreId +=1
            baseNamePreIdStr = str(baseNamePreId)
            newPath = dirName + "/" + baseNamePrePre + "_" + baseNamePreIdStr + "." + baseNameExt
            
            if not os.access(newPath, os.R_OK):
                break
        
            allPaths.append(newPath)
            
        if allPaths == []:
            continue'''
        ############### ^ delete1 ^ ###############
        
        allPaths_list = []
        ############### v delete2 v ###############
        '''allPaths_list.append(allPaths)
        baseNamePrePreRec = baseNamePrePre'''
        ############### ^ delete2 ^ ###############
        
        # randomize others !!!!!!!!!! -----------------------------------------
        # new added:
        
        allPathsExtra = []
        for j in range(len(allFileNodes)):
            ############### v delete3 v ###############
            '''if j == 0:
                continue'''
            ############### ^ delete3 ^ ###############
            
            if cmds.nodeType(allFileNodes[j]) == "file":
                texMaster = cmds.getAttr(allFileNodes[j] + ".fileTextureName")
            elif cmds.nodeType(allFileNodes[j]) == "octaneImageTexture":
                texMaster = cmds.getAttr(allFileNodes[j] + ".File")
                # need transfer to abs path
                if not os.access(texMaster, os.R_OK):
                    projectFolder = cmds.workspace( q = True, rd = True)
                    texMaster = projectFolder + texMaster
            elif cmds.nodeType(allFileNodes[j]) == "aiImage":
                texMaster = cmds.getAttr(allFileNodes[j] + ".filename")
                
            texNew = udimSwapTest(texMaster)
            if texNew != None:
                udimSwap = True
                orgFileName = texMaster
                texMaster = texNew
            
            
            if texMaster == None:
                allPaths_list.append([])
                continue
            if not os.access(texMaster, os.R_OK):
                allPaths_list.append([])
                continue
            #                                                               # d:/abc/bbb/kkk_ggg_0.jpg  (master)
            dirName = os.path.dirname(texMaster)                            # d:/abc/bbb                (dir)
            baseName = os.path.basename(texMaster)                          # kkk_ggg_0.jpg             (base)
                
            baseNameExt = baseName.split(".")[-1]                           # jpg                       (extension)
            baseNamePre = baseName.split("." + baseNameExt)[0]              # kkk_ggg_0                 (base pre)
            lastUS = baseNamePre.rfind("_")
            if lastUS <= 0:
                allPaths_list.append([])
                continue
            baseNamePrePre = baseNamePre[0 : lastUS]                        # kkk_ggg                   (base pre pre)
            baseNamePreIdStr = baseNamePre[lastUS+1 : len(baseNamePre)]     # 0                         (pre id)
            
            if not baseNamePreIdStr.isdigit():
                allPaths_list.append([])
                continue
            
            baseNamePreId = int(baseNamePreIdStr)
            baseNamePreIdStr = str(baseNamePreId)
            
            newPath = dirName + "/" + baseNamePrePre + "_" + baseNamePreIdStr + "." + baseNameExt
            if not os.access(newPath, os.R_OK):
                allPaths_list.append([])
                continue
            
            allPathsExtra = []
            while(True):
                baseNamePreId +=1
                baseNamePreIdStr = str(baseNamePreId)
                newPath = dirName + "/" + baseNamePrePre + "_" + baseNamePreIdStr + "." + baseNameExt
                
                if not os.access(newPath, os.R_OK):
                    break
            
                allPathsExtra.append(newPath)
                
            if allPathsExtra == []:
                allPaths_list.append([])
                continue
            
            allPaths_list.append(allPathsExtra)
            
        
        # duplicate shaders:
        allNewShaders = []
        
        
        ####for n in range(len(allPaths)):
        for n in range(len(allPathsExtra)):#### change variable to delete 'delete1'
            newShader = cmds.duplicate(currentShader, n = "McdShd_" + currentShader, un = True)[0] #input connection

            allHisNew = cmds.listHistory(newShader)
            if McdIsBlank(allHisNew):
                continue
             
            allFileNodesNew = []
            for j in range(len(allHisNew)): 
                if cmds.nodeType(allHisNew[j]) == "file" or cmds.nodeType(allHisNew[j]) == "octaneImageTexture" or cmds.nodeType(allHisNew[j]) == "aiImage":
                    allFileNodesNew.append(allHisNew[j])
                    
            for j in range(len(allFileNodesNew)):

                if len(allPaths_list[j]) > n:
                    #fillPath = allPaths_list[j][n]
                    
                    if cmds.nodeType(allFileNodes[j]) == "file":
                        texTemp = cmds.getAttr(allFileNodesNew[j] + ".fileTextureName")
                    elif cmds.nodeType(allFileNodes[j]) == "aiImage":
                        texTemp = cmds.getAttr(allFileNodesNew[j] + ".filename")
                    
                    fillPath = learnImageIndex(allPaths_list[j][n], texTemp)
                    if fillPath == None:
                        continue
                    
                    if cmds.nodeType(allFileNodes[j]) == "file":
                        currentTex = cmds.getAttr(allFileNodesNew[j] + ".fileTextureName")
                        cmds.setAttr(allFileNodesNew[j] + ".fileTextureName", fillPath, type = "string")
                        
                    elif cmds.nodeType(allFileNodes[j]) == "octaneImageTexture":
                        currentTex = cmds.getAttr(allFileNodesNew[j] + ".File")
                        cmds.setAttr(allFileNodesNew[j] + ".File", fillPath, type = "string")
                        
                    elif cmds.nodeType(allFileNodes[j]) == "aiImage":
                        currentTex = cmds.getAttr(allFileNodesNew[j] + ".filename")
                        cmds.setAttr(allFileNodesNew[j] + ".filename", fillPath, type = "string")
                        
                        
            allNewShaders.append(newShader)
            
            try:
                cmds.connectAttr(currentShader + ".copy", newShader + ".copy")
            except:
                pass
        
        # if can:
        # find all obj relative with this shader
        cmds.hyperShade(objects = currentShader)
        # rdoSelectWithMaterial(currentShader)  # RODEO EDIT
        selObjs = cmds.ls(sl = True)
        if McdIsBlank(selObjs):
            continue
        
        selObjs.sort()
        
        exeObjs = []
        for j in range(len(selObjs)):
            if not McdIsAgentGeo(selObjs[j]):
                exeObjs.append(selObjs[j])
                
        if exeObjs == []:
            continue
        
        for j in range(len(exeObjs)):
            agSeed = -1
            try:
                agSeed = cmds.getAttr(exeObjs[j] + ".agSeed")
            except:
                agSeed = -1
            agentId = -1
            if agSeed != -1:
                try:
                    parentNode = cmds.listRelatives(exeObjs[j], p = True, c = False)[0]
                    agentId = cmds.getAttr(parentNode + ".agentId")
                except:
                    agentId = -1
            
            # select random shader
            min = 0
            max = len(allNewShaders) + 1
            
            
            seed = int((float(i) + 0.797) * 1.71 + (float(j) + 0.877) * 1.77)
            
            if agSeed != -1:
                
                seed = int((float(agentId) + 0.797) * 1.71)
                
            randNum = int(McdSolveASeedMinMax(seed, 11.457, min, max))
            
            if randNum >= max - 1:
                continue
            
            cmds.select(exeObjs[j])
            try:
                cmds.hyperShade( assign = allNewShaders[randNum] )
                # for obj in pm.ls(sl=1):
                #     rdoAssignMaterialToObject(allNewShaders[randNum], obj)  # RODEO EDIT
            except:
                pass

def McdClearUselessShader():
    
    allDupShader = cmds.ls("McdShd_*")
    
    for i in range(len(allDupShader)):
        currentType = cmds.nodeType(allDupShader[i])
        
        try:
            allHis = cmds.listHistory(allDupShader[i])
            if not McdIsBlank(allHis):
                for j in range(len(allHis)):
                    try:
                        if cmds.nodeType(allHis[j]) == currentType and allHis[j].find("McdShd_") < 0:
                            continue
                        cmds.delete(allHis[j])
                    except:
                        pass
            else:
                try:
                    cmds.delete(allDupShader[i])
                except:
                    pass
        except:
            pass
            
            
def udimSwapTest(inTex):
    
    udimKey = "<udim>"
    if inTex.find("<UDIM>") > 0:
        udimKey = "<UDIM>"
        
    
    if inTex.find(udimKey) > 0:
        print "* In Tex: " + inTex
        dirName = os.path.dirname(inTex)
        imgName = os.path.basename(inTex)
        
        imgSeg = imgName.split(udimKey)
        pattern = re.compile(imgSeg[0] + "\d\d\d\d*")
        print '* re pattern: '+ imgSeg[0] + "\d\d\d\d*"
        print "* Tex Folder: " + dirName
        if not os.access(dirName, os.R_OK):
            print "* Cannot access X X X X X"
            print "* ------- "
            return None
        
        allFiles = os.listdir(dirName)
        
        if allFiles == []:
            print "* No files O O O O O"
            print "* ------- "
            return None
        
        allFiles.sort()
        
        for i in range(len(allFiles)):
            print "*   " + allFiles[i]
        
        matchList = []
        for i in range(len(allFiles)):
            isMatch = pattern.match(allFiles[i])
            
            if isMatch:
                matchList.append(allFiles[i])
                
        print "* match num: " + str(len(matchList))
                
        if len(matchList) > 1:
            print "* :::: RETURN : " + dirName + "/" + matchList[0]
            print "* ------- "
            return dirName + "/" + matchList[0]
        else:
            print "* ------- "
            return None
        
        
    print "* ------- "
    return None


def swapUdimBack(fillPath, orgFileName):
    
    dirDigi = os.path.dirname(fillPath)
    imgDigi = os.path.basename(fillPath)
    
    dirUdim = dirDigi
    imgUdim = os.path.basename(orgFileName)
    
    
    udimKey = "<udim>"
    if imgUdim.find("<UDIM>") > 0:
        udimKey = "<UDIM>"
        
    
    p = imgUdim.find(udimKey)
    imgDigiLen = len(imgDigi)
    pre = imgDigi[0:p]
    post = imgDigi[p+4:17]
    
    newPath = dirUdim + "/" + pre + udimKey + post
    
    return newPath

    
def McdRandomizeTexturesDSO(renderer, shaderFile, isExport = True):
    # for arnold render!
    
    # find all agent geo
    # find all shaders
    # for each shader:
    #     test is this can be randmize
    #     if can: find all obj relative with this shader
    #         duplicate shaders node based on number
    
    print ""
    print "*********************************************************************"
    print "************        Print Texture Randomize Info        *************"
    print "*"
    
    # find all agent geo -------------------------------------------------------
    allGeoGrp = cmds.ls("*Geometry_*")
    allGeoGrpRef = cmds.ls("*:Geometry_*")
    allGeoGrp.extend(allGeoGrpRef)
    if McdIsBlank(allGeoGrp):
        return
    allGeoGrpList = []
    for i in range(len(allGeoGrp)):
        geoGrpParent = cmds.listRelatives(allGeoGrp[i], p = True, c = False)
        if McdIsBlank(geoGrpParent):
            continue
        if cmds.nodeType(geoGrpParent[0]) == "McdAgentGroup":
            allGeoGrpList.append(allGeoGrp[i])
    
    allGeos = []
    for i in range(len(allGeoGrpList)):
        allSubNodes = cmds.listRelatives(allGeoGrpList[i], c = True, p = False, ad = True, path = True)
        if McdIsBlank(allSubNodes):
            continue
        for j in range(len(allSubNodes)):
            if cmds.nodeType(allSubNodes[j]) == "mesh":
                if not cmds.getAttr(allSubNodes[j] + ".intermediateObject"):
                    allGeos.append(allSubNodes[j])
    if allGeos == []:
        return
    
    # find all shaders ---------------------------------------------------------
    allShdGrp = []
    for i in range(len(allGeos)):
        allConns = cmds.listConnections(allGeos[i], d = True, s = False)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if cmds.nodeType(allConns[j]) == "shadingEngine":
                if allConns[j] not in allShdGrp:
                    allShdGrp.append(allConns[j])
    if allShdGrp == []:
        return
        
    allShdGrpCorrect = []
    allShaders = []
    allDispMaps = []
    for i in range(len(allShdGrp)):
        allConns = cmds.listConnections(allShdGrp[i], s = True, d = False, p = True)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if allConns[j].find(".outColor") > 0:
                shaderName = allConns[j].split(".outColor")[0]
                if shaderName not in allShaders:
                    allShaders.append(shaderName)
                    allShdGrpCorrect.append(allShdGrp[i])
                    
                    disMap = ""
                    # continue find the displacement:
                    for k in range(len(allConns)):
                        if allConns[k].find(".displacement") > 0:
                            disMap = allConns[k].split(".displacement")[0]
                    allDispMaps.append(disMap)
                
    if allShaders == []:
        return


    duplicatedObject = []
    allDupPlanes = []
    allExportSGNode = allShdGrpCorrect
    
    # for each shaders: --------------------------------------------------------
    baseNamePrePreRec = ""
    
    for i in range(len(allShaders)):
        
        udimSwap = False
        orgFileName = ""
        
        # test is this can be randmize
        # find outColor node, 'file' node --------------------------------------
        currentShader = allShaders[i]
        currentDispMap = allDispMaps[i]
        belongingSG = allShdGrpCorrect[i]
        
        # assign the existed obj ----------------------------------------------------
        # assign itself:
        if renderer == "vray":
            newPlane = cmds.polyPlane(sx = 1, sy = 1, n = "TempVRayShaderPlane")[0]
        else:
            newPlane = cmds.polyPlane(sx = 1, sy = 1, n = "TempArnoldShaderPlane")[0]
        duplicatedObject.append(newPlane)
        allDupPlanes.append(newPlane)
        # cmds.hyperShade(newPlane, assign = currentShader )
        rdoAssignMaterialToObject(currentShader, newPlane)  # RODEO EDIT

        # assign the existed obj ----------------------------------------------------
        
        
        allUtilNodes = []
        allHis = cmds.listHistory(belongingSG)
        if len(allHis) > 0:
            for j in range(len(allHis)):
                if cmds.nodeType(allHis[j]) == "aiUtility":
                    allUtilNodes.append(allHis[j])
        
        
        allHis = cmds.listHistory(currentShader)
        if McdIsBlank(allHis):
            continue
        allFileNodes = []
        for j in range(len(allHis)):
            if cmds.nodeType(allHis[j]) == "file" or cmds.nodeType(allHis[j]) == "aiImage":
                allFileNodes.append(allHis[j])
        if allFileNodes == []:
            continue
        
        fileNodeColor = ""
        for j in range(len(allFileNodes)):
            if cmds.nodeType(allFileNodes[j]) == "file":
                texTemp = cmds.getAttr(allFileNodes[j] + ".fileTextureName")
            else:
                texTemp = cmds.getAttr(allFileNodes[j] + ".filename")
                
            texNew = udimSwapTest(texTemp)
            if texNew != None:
                udimSwap = True
                orgFileName = texTemp
                texTemp = texNew
                
            thdPart = texTemp.split("_")[-1]
            secPart = thdPart.split(".")[0]
            if secPart.isdigit():
                fileNodeColor = allFileNodes[j]
                break
        
        if fileNodeColor == "":
            continue
            

        if cmds.nodeType(fileNodeColor) == "file":
            texMaster = cmds.getAttr(fileNodeColor + ".fileTextureName")
        else:
            texMaster = cmds.getAttr(fileNodeColor + ".filename")
            
        texNew = udimSwapTest(texMaster)
        if texNew != None:
            udimSwap = True
            orgFileName = texMaster
            texMaster = texNew
            
        if texMaster == None:
            print "# # Miarmy Error: texture path not set."
            continue
        if not os.access(texMaster, os.R_OK):
            print "# # Miarmy Error: texture path not correct."
            continue
        #                                                               # d:/abc/bbb/kkk_ggg_0.jpg  (master)
        dirName = os.path.dirname(texMaster)                            # d:/abc/bbb                (dir)
        baseName = os.path.basename(texMaster)                          # kkk_ggg_0.jpg             (base)
            
        baseNameExt = baseName.split(".")[-1]                           # jpg                       (extension)
        baseNamePre = baseName.split("." + baseNameExt)[0]              # kkk_ggg_0                 (base pre)
        lastUS = baseNamePre.rfind("_")
        if lastUS <= 0:
            continue
        baseNamePrePre = baseNamePre[0 : lastUS]                        # kkk_ggg                   (base pre pre)
        baseNamePreIdStr = baseNamePre[lastUS+1 : len(baseNamePre)]     # 0                         (pre id)
        
        if not baseNamePreIdStr.isdigit():
            continue
        
        baseNamePreId = int(baseNamePreIdStr)
        baseNamePreIdStr = str(baseNamePreId)
        
        newPath = dirName + "/" + baseNamePrePre + "_" + baseNamePreIdStr + "." + baseNameExt
        if not os.access(newPath, os.R_OK):
            continue
        
        allPaths = []
        while(True):
            baseNamePreId +=1
            baseNamePreIdStr = str(baseNamePreId)
            newPath = dirName + "/" + baseNamePrePre + "_" + baseNamePreIdStr + "." + baseNameExt
            
            if not os.access(newPath, os.R_OK):
                break
        
            allPaths.append(newPath)
            
        if allPaths == []:
            continue
        
        
        # duplicate shaders:
        allNewShaders = []
        allNewSGNodes = []
        allNewDisMaps = []
        for n in range(len(allPaths)):
            strn = str(n)
            newShader = cmds.duplicate(currentShader, un = True, n = currentShader + "__mcd" + strn)[0] #input connection
            newSGNode = cmds.duplicate(belongingSG, n = belongingSG + "__mcd" + strn)[0] #new sg node
            cmds.connectAttr(belongingSG + ".caching", newSGNode + ".caching")
            duplicatedObject.append(newShader)
            duplicatedObject.append(newSGNode)
            if currentDispMap != "":
                newDisMap = cmds.duplicate(currentDispMap, un = True, n = currentDispMap + "__mcd" + strn)[0] #new sg node
                duplicatedObject.append(newDisMap)
            
            if allUtilNodes != []:
                for i in range(len(allUtilNodes)):
                    stri = str(i)
                    cmds.connectAttr( allUtilNodes[i] + ".outColor", newSGNode + ".aiCustomAOVs[" + stri + "].aovInput")


            allFileNodesNew = [] 
            allHisNew = cmds.listHistory(newShader)
            if McdIsBlank(allHisNew):
                continue
           
            for j in range(len(allHisNew)):
                if cmds.nodeType(allHisNew[j]) == "file" or cmds.nodeType(allHisNew[j]) == "aiImage":
                    allFileNodesNew.append(allHisNew[j])
                    
            #if currentDispMap != "":
            #    allHisNew = cmds.listHistory(newDisMap)
            #    if not McdIsBlank(allHisNew):
            #        for j in range(len(allHisNew)):
            #            if cmds.nodeType(allHisNew[j]) == "file" or cmds.nodeType(allHisNew[j]) == "aiImage":
            #                if allHisNew[j] not in allFileNodes:
            #                    allFileNodesNew.append(allHisNew[j])
                            
                            
            for j in range(len(allFileNodesNew)):
                if cmds.nodeType(allFileNodesNew[j]) == "file":
                    texTemp = cmds.getAttr(allFileNodesNew[j] + ".fileTextureName")
                else:
                    texTemp = cmds.getAttr(allFileNodesNew[j] + ".filename")
                    
                fillPath = learnImageIndex(allPaths[n], texTemp)
                
                if fillPath == None:
                    continue
                
                print "* SRC: " + allPaths[n]
                print "* ORG: " + texTemp
                print "* NEW: " + fillPath
                
                if cmds.nodeType(allFileNodesNew[j]) == "file":
                    currentTex = cmds.getAttr(allFileNodesNew[j] + ".fileTextureName")
                    cmds.setAttr(allFileNodesNew[j] + ".fileTextureName", fillPath, type = "string")
                else:
                    currentTex = cmds.getAttr(allFileNodesNew[j] + ".filename")
                    cmds.setAttr(allFileNodesNew[j] + ".filename", fillPath, type = "string")
                    
            
            allNewShaders.append(newShader)
            allNewSGNodes.append(newSGNode)
            
            # connect shader to shading group:
            cmds.connectAttr( newShader + ".outColor", newSGNode + ".surfaceShader", f = True)
            if currentDispMap != "":
                cmds.connectAttr( newDisMap + ".displacement", newSGNode + ".displacementShader", f = True)
        
        
        allExportSGNode.extend(allNewSGNodes)
        
        # assign shader:
        for j in range(len(allNewSGNodes)):
            newPlane = ""
            if renderer == "vray":
                newPlane = cmds.polyPlane(sx = 1, sy = 1, n = "TempVRayShaderPlane")[0]
            else:
                newPlane = cmds.polyPlane(sx = 1, sy = 1, n = "TempArnoldShaderPlane")[0]
            duplicatedObject.append(newPlane)
            allDupPlanes.append(newPlane)
            # cmds.hyperShade(newPlane, assign = allNewShaders[j] )
            rdoAssignMaterialToObject(allNewShaders[j], newPlane)  # RODEO EDIT

 
    allarp = cmds.ls("TempArnoldShaderPlane*", type = "shape")
    if not MIsBlank(allarp):
        for i in range(len(allarp)):
            print allarp[i]
            allConns = cmds.listConnections(allarp[i], s = False, d = True)
            if not MIsBlank(allConns):
                for j in range(len(allConns)):
                    if cmds.nodeType(allConns[j]) == "shadingEngine":
                        print "    -> " + allConns[j]
    
    
    if renderer == "arnold":
        melCmd = 'arnoldExportAss -f "' + shaderFile + '" -asciiAss -mask 16 -lightLinks 0 -shadowLinks 0;'
        if isExport:
            mel.eval(melCmd)
        
    
    if renderer == "mentalray":
        cmds.select(allExportSGNode, ne = True)
        melCmd = 'Mayatomr -mi -e -exportFilter 2089719 -active -fe -fem -fis -xp "3313333333" -file "' + shaderFile + '";'
        if isExport:
            mel.eval(melCmd)
        
    if renderer == "vray":
        if allDupPlanes != []:
            newNode = cmds.createNode("transform", n = "TempVRayShaderPlaneRoot")
            cmds.parent(allDupPlanes, newNode)
            cmds.hide("TempVRayShaderPlaneRoot")
    
    
    return duplicatedObject

def learnImageIndex(texFile, inPath):
    
    if inPath.find("DISP") > 0 or inPath.find("disp") > 0:
        return None
    
    # copy index from texFile to inPath
    
    baseName = os.path.basename(texFile)                            # kkk_ggg_2.jpg             (base)
        
    baseNameExt = baseName.split(".")[-1]                           # jpg                       (extension)
    baseNamePre = baseName.split("." + baseNameExt)[0]              # kkk_ggg_2                 (base pre)
    lastUS = baseNamePre.rfind("_")
    if lastUS <= 0:
        return None
    baseNamePrePre = baseNamePre[0 : lastUS]                        # kkk_ggg                   (base pre pre)
    baseNamePreIdStr = baseNamePre[lastUS+1 : len(baseNamePre)]     # 2                         (pre id)
    
    sourceIndexStr = baseNamePreIdStr




    # copy to the inPath:
    
    dirName = os.path.dirname(inPath)                               # d:/abc/bbb                (dir)
    baseName = os.path.basename(inPath)                             # kkk_ggg_0.jpg             (base)
        
    baseNameExt = baseName.split(".")[-1]                           # jpg                       (extension)
    baseNamePre = baseName.split("." + baseNameExt)[0]              # kkk_ggg_0                 (base pre)
    lastUS = baseNamePre.rfind("_")
    if lastUS <= 0:
        return None
    baseNamePrePre = baseNamePre[0 : lastUS]                        # kkk_ggg                   (base pre pre)
    baseNamePreIdStr = baseNamePre[lastUS+1 : len(baseNamePre)]     # 0                         (pre id)
    
    if not baseNamePreIdStr.isdigit():
        return None
    
    newPath = dirName + "/" + baseNamePrePre + "_" + sourceIndexStr + "." + baseNameExt
    
    if newPath.find("<udim>") >= 0 or newPath.find("<UDIM>") >= 0:
        return newPath
    
    if not os.access(newPath, os.R_OK):
        return None
    
    return newPath
    


    
def clearUselessObjAndShaders(duplicatedObject):
    
    if MIsBlank(duplicatedObject):
        return
    
    for i in range(len(duplicatedObject)):
        try:
            allHis = cmds.listHistory(duplicatedObject[i])
            if not MIsBlank(allHis):
                for j in range(len(allHis)):
                    
                    if cmds.nodeType(allHis[j]) == "shadingEngine" and allHis[j].find("__mcd") < 0:
                        continue;
                    
                    if cmds.nodeType(allHis[j]) == "aiUtility":
                        continue;
                    
                    try:
                        cmds.delete(allHis[j])
                    except:
                        pass
        except:
            pass
    
    for i in range(len(duplicatedObject)):
        try:
            cmds.delete(duplicatedObject[i])
        except:
            pass

def clearUselessObjAndShadersVRay():
    
    duplicatedObject = cmds.ls("*__mcd*", "TempVRayShader*")
    
    for i in range(len(duplicatedObject)):
        try:
            allHis = cmds.listHistory(duplicatedObject[i])
            if not MIsBlank(allHis):
                for j in range(len(allHis)):
                    
                    if cmds.nodeType(allHis[j]) == "shadingEngine" and allHis[j].find("__mcd") < 0:
                        continue;
                    
                    try:
                        cmds.delete(allHis[j])
                    except:
                        pass
        except:
            pass
    
    for i in range(len(duplicatedObject)):
        try:
            cmds.delete(duplicatedObject[i])
        except:
            pass


def McdDuplicateShaderForAutoTexGeo():
    allGeoGrp = cmds.ls("*Geometry_*")
    allGeoGrpRef = cmds.ls("*:Geometry_*")
    allGeoGrp.extend(allGeoGrpRef)
    if McdIsBlank(allGeoGrp):
        return
    allGeoGrpList = []
    for i in range(len(allGeoGrp)):
        geoGrpParent = cmds.listRelatives(allGeoGrp[i], p = True, c = False)
        if McdIsBlank(geoGrpParent):
            continue
        if cmds.nodeType(geoGrpParent[0]) == "McdAgentGroup":
            allGeoGrpList.append(allGeoGrp[i])
    
    allGeos = []
    for i in range(len(allGeoGrpList)):
        allSubNodes = cmds.listRelatives(allGeoGrpList[i], c = True, p = False, ad = True, path = True)
        if McdIsBlank(allSubNodes):
            continue
        for j in range(len(allSubNodes)):
            if cmds.nodeType(allSubNodes[j]) == "mesh":
                if not cmds.getAttr(allSubNodes[j] + ".intermediateObject"):
                    canAdd = False
                    try:
                        cmds.getAttr(allSubNodes[j] + ".autoTex")
                        canAdd = True
                    except:
                        pass
                    
                    # bypass the texture sequence ones
                    if canAdd:
                        allGeos.append(allSubNodes[j])

    if allGeos == []:
        return
    
    # find all shaders ---------------------------------------------------------
    allShdGrp = []
    for i in range(len(allGeos)):
        allConns = cmds.listConnections(allGeos[i], d = True, s = False)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if cmds.nodeType(allConns[j]) == "shadingEngine":
                if allConns[j] not in allShdGrp:
                    allShdGrp.append(allConns[j])
    if allShdGrp == []:
        return
        
    allShdGrpCorrect = []
    allShaders = []
    for i in range(len(allShdGrp)):
        allConns = cmds.listConnections(allShdGrp[i], s = True, d = False, p = True)
        if McdIsBlank(allConns):
            continue
        for j in range(len(allConns)):
            if allConns[j].find(".outColor") > 0:
                shaderName = allConns[j].split(".outColor")[0]
                if shaderName not in allShaders:
                    allShaders.append(shaderName)
                    allShdGrpCorrect.append(allShdGrp[i])
    if allShaders == []:
        return
    
    # for each shaders: --------------------------------------------------------
    for i in range(len(allShaders)):
        # test is this can be randmize
        # find outColor node, "file" node --------------------------------------
        currentShader = allShaders[i]
        belongingSG = allShdGrpCorrect[i]
        
        # get all need duplicated objects!
        setObjs = cmds.sets( belongingSG, q = True ) # select from set
        cmds.select(setObjs)
        selObjs = cmds.ls(sl = True)
        if McdIsBlank(selObjs):
            continue
        exeObjs = selObjs
        
        # duplicate shaders:
        for j in range(len(exeObjs)):
            transObj = cmds.listRelatives(exeObjs[j], p = True, c = False)[0]
            segments = transObj.split("MDGGrp_")
            agid = -1
            if len(segments) == 2:
                agidStr = segments[1]
                agid = int(agidStr)
                
            if agid == -1:
                continue
            
            newShader = cmds.duplicate(currentShader, un = True)[0] #input connection
            newSGNode = cmds.duplicate(belongingSG)[0] #new sg node
            
            # mark file node
            allHis = cmds.listHistory(newShader)
            if allHis != [] and allHis != None:
                for k in range(len(allHis)):
                    if cmds.nodeType(allHis[k]) == "file":
                        fileNode = allHis[k]
                        cmds.addAttr(fileNode, ln = "agid", at = "long")
                        cmds.setAttr(fileNode + ".agid", agid)
                        
                        cmds.addAttr(fileNode, ln = "defPath", dt = "string")
                        defPath = cmds.getAttr(fileNode + ".fileTextureName")
                        cmds.setAttr(fileNode + ".defPath", defPath, type = "string")
                        
            
            # connect shader to shading group:
            cmds.connectAttr( newShader + ".outColor", newSGNode + ".surfaceShader", f = True)
        
            cmds.sets(exeObjs[j], e = True, forceElement = newSGNode)

            
def McdMarkAutoTex():
    selObj = getSelection("mesh")
    try:
        cmds.addAttr(selObj, ln = "autoTex", at = "bool", dv = 1)
    except:
        cmds.confirmDialog(t = "Abort", m = "Already marked.")
        pass

def McdClearAutoTex():
    selObj = getSelection("mesh")
    try:
        cmds.select(selObj)
        cmds.deleteAttr(n = selObj, at = "autoTex")
    except:
        pass

def McdCreateTexSeqRule():
    #masterNode = cmds.ls("McdAutoTexRulesMarkers")
    #if MIsBlank(masterNode):
    #    cmds.createNode("transform", n = "McdAutoTexRulesMarkers")
    #    
    #masterNode = "McdAutoTexRulesMarkers"
    
    marker = cmds.spaceLocator(n = "McdAutoTexRule")[0]
    
    cmds.addAttr(marker, ln = "typeId", at = "long")
    cmds.addAttr(marker, ln = "linkActions", at = "bool")
    cmds.addAttr(marker, ln = "texturePathPre", dt = "string")
    cmds.addAttr(marker, ln = "textureFormat", dt = "string")
    
def McdLinkAutoTexAction():
    selObjs = cmds.ls(sl = True)
    if MIsBlank(selObjs):
        cmds.confirmDialog(t = "Error", m = "Please firstly select one maker and then action(s).")
        return
    
    if len(selObjs) < 2:
        cmds.confirmDialog(t = "Error", m = "Please firstly select one maker and then action(s).")
        return
    
    for i in range(len(selObjs)):
        if i == 0:
            continue
        else:
            try:
                cmds.connectAttr(selObjs[0] + ".linkActions", selObjs[i] + ".linkAction")
                cmds.setAttr(selObjs[0] + ".linkActions", 1)
            except:
                pass
            
    cmds.confirmDialog(t = "Done", m = "Link done, please check Hypergraph")
        

def McdPostDriveMeshAutoTex():
    cmd = "McdSimpleCommand -exe 8"
    result = mel.eval(cmd)
    
    if MIsBlank(result):
        return
    
    nbAgent = int(result[0])
    info = []
    for i in range(nbAgent * 3 + 1):
        if i == 0:
            continue
        info.append(result[i])
        
    allFNodes = cmds.ls(type = "file")
    
    if MIsBlank(allFNodes):
        return
    
    # find all rules:
    allRules = cmds.ls("McdAutoTexRule*", type = "transform")
    if MIsBlank(allRules):
        return
    
    allTids = []
    allActions = []
    allAG = cmds.ls(type = "McdAgentGroup")
    for i in range(len(allAG)):
        cmds.select(allAG[i])
        
        cmd = "McdSimpleCommand -exe 9"
        result = mel.eval(cmd)
        
        if MIsBlank(result):
            continue
            
        allTids.append(cmds.getAttr(allAG[i] + ".tid"))
        allActions.append(result)
    
    agid = -1
    for i in range(len(allFNodes)):
        try:
            agid = cmds.getAttr(allFNodes[i] + ".agid")
        except:
            continue
        
        tid = int(info[agid * 3 + 0])
        actid = int(info[agid * 3 + 1])
        cframe = int(info[agid * 3 + 2])
        if cframe < 0 or actid < 0:
            defPath = cmds.getAttr(allFNodes[i] + ".defPath")
            cmds.setAttr(allFNodes[i] + ".fileTextureName", defPath, type = "string")
        
        frameStr = str(cframe)
        while(len(frameStr) < 4):
            frameStr = "0" + frameStr
        
        
        typeIndex = MIndexOf(tid, allTids)

        if typeIndex == -1:
            continue
        
        actName = ""
        try:
            actName = allActions[typeIndex][actid]
        except:
            pass
        
        #//////////////////////////////
        #print "tid: " + str(tid)
        #print actName
        #print "frame: " + str(cframe)
        #//////////////////////////////
        
        # find rule node:
        # compare the type
        # compare the action
        # if match, try to set texture
        
        matchRule = False
        for j in range(len(allRules)):
            
            if tid != cmds.getAttr(allRules[j] + ".typeId"):
                continue
            
            # find all action node:
            allLinkActions = cmds.listConnections(allRules[j], s = False, d = True)
            if MIsBlank(allLinkActions):
                continue
            
            if MIndexOf(actName, allLinkActions) < 0:
                continue
            
            matchRule = True
            
            # execute and break
            format = cmds.getAttr(allRules[j] + ".textureFormat")
            texPre = cmds.getAttr(allRules[j] + ".texturePathPre")
            texPre += "." + frameStr + "."
            tex = texPre + format
            
            if not os.access(tex, os.R_OK):
                print "not access"
                defPath = cmds.getAttr(allFNodes[i] + ".defPath")
                cmds.setAttr(allFNodes[i] + ".fileTextureName", defPath, type = "string")
            else:
                cmds.setAttr(allFNodes[i] + ".fileTextureName", tex, type = "string")
        
            break
        
        if not matchRule:
            # set default:
            defPath = cmds.getAttr(allFNodes[i] + ".defPath")
            cmds.setAttr(allFNodes[i] + ".fileTextureName", defPath, type = "string")
        
        
def McdShaderMap():
    # for selected 
    selObj = getSelection("mesh")
    # find root shader
    # find copy shaders
    allShdGrp = ""
    allConns = cmds.listConnections(selObj, d = True, s = False)
    if McdIsBlank(allConns):
        return
    for j in range(len(allConns)):
        if cmds.nodeType(allConns[j]) == "shadingEngine":
            allShdGrp = allConns[j]
    if allShdGrp == "":
        return
    
    allShaders = ""
    allConns = cmds.listConnections(allShdGrp, s = True, d = False, p = True)
    if McdIsBlank(allConns):
        return
    for j in range(len(allConns)):
        if allConns[j].find(".outColor") > 0:
            shaderName = allConns[j].split(".outColor")[0]
            allShaders = shaderName
    if allShaders == "":
        return
    
    allConns = cmds.listConnections(allShaders, s = False, d = True, p = True)
    if McdIsBlank(allConns):
        return
    
    allCopy = []
    for i in range(len(allConns)):
        if allConns[i].find(".copy") > 0:
            copyName = allConns[i].split(".")[0]
            allCopy.append(copyName)
            
    if allCopy == []:
        cmds.confirmDialog(t = "Abort", m = "No copies found, please\nSelect the geom from original agent, or \nclear and re-random again for establishing the relationship.")
        return
    
    allAttrs = cmds.listAttr(allShaders)
    
    for i in range(len(allCopy)):
        for j in range(len(allAttrs)):
            try:
                attrVal = cmds.getAttr(allShaders + "." + allAttrs[j])
                cmds.setAttr(allCopy[i] + "." + allAttrs[j], attrVal)
            except:
                pass



def McdReRandomizeSelAgentTextures():
    allSelObjs = cmds.ls(sl = True)
    if MIsBlank(allSelObjs):
        cmds.confirmDialog(t = "Abort", m = "Please select some duplicated agents.")
        return
    
    allMDObj = []
    for i in range(len(allSelObjs)):
        if allSelObjs[i].find("MDGGrp_") == 0:
            allMDObj.append(allSelObjs[i])
            
    if MIsBlank(allMDObj):
        cmds.confirmDialog(t = "Abort", m = "Please select some duplicated agents.")
        return
    
    for i in range(len(allMDObj)):
        allMesh = cmds.listRelatives(allMDObj[i], c = True, p = False)
        if MIsBlank(allMesh):
            continue
        for j in range(len(allMesh)):
            meshObj = allMesh[j];
            
            allShdGrp = ""
            allConns = cmds.listConnections(meshObj, d = True, s = False)
            if McdIsBlank(allConns):
                continue

            for k in range(len(allConns)):
                if cmds.nodeType(allConns[k]) == "shadingEngine":
                    allShdGrp = allConns[k]
            if allShdGrp == "":
                continue
            
            allShaders = ""
            allConns = cmds.listConnections(allShdGrp, s = True, d = False, p = True)
            if McdIsBlank(allConns):
                continue
            for k in range(len(allConns)):
                if allConns[k].find(".outColor") > 0:
                    shaderName = allConns[k].split(".outColor")[0]
                    allShaders = shaderName
            if allShaders == "":
                continue
            
            allConns = cmds.listConnections(allShaders, s = False, d = True, p = True)
            if McdIsBlank(allConns):
                continue
            
            allCopy = []
            for k in range(len(allConns)):
                if allConns[k].find(".copy") > 0:
                    copyName = allConns[k].split(".")[0]
                    allCopy.append(copyName)
                    
            if allCopy == []:
                allConns = cmds.listConnections(allShaders, d = False, s = True, p = True)
                if McdIsBlank(allConns):
                    continue
                
                root = ""
                for l in range(len(allConns)):
                    if allConns[l].find(".copy") > 0:
                        root = allConns[l].split(".")[0]
                        break
                        
                if root != "":
                    allConns = cmds.listConnections(root, s = False, d = True, p = True)
                    if McdIsBlank(allConns):
                        continue
                    
                    for l in range(len(allConns)):
                        if allConns[l].find(".copy") > 0:
                            copyName = allConns[l].split(".")[0]
                            allCopy.append(copyName)
                            
                    allCopy.append(root)
                    allCopy.remove(allShaders)
                            
            # select one form allCopy
            if allCopy == []:
                continue
    
            randNum = random.randint(0, len(allCopy)-1)
            

            allConnss = cmds.listConnections(allCopy[randNum], d = True, s = False)
            sgNodeNew = ""
            for x in range(len(allConnss)):
                if cmds.nodeType(allConnss[x]) == "shadingEngine":
                    sgNodeNew = allConnss[x]
                    break
                
            if sgNodeNew == "":
                continue;
            
            cmds.sets(allMesh[j], e = True, forceElement = sgNodeNew)
            
        
        
#def McdClearTrashNode():
#    
#    allSGNode = cmds.ls(type = "shadingEngine")
#    for i in range(len(allSGNode)):
#        if allSGNode[i].find("__mcd") > 0:
#            print allSGNode[i]
#            allHis = cmds.listHistory(allSGNode[i])
#            for j in range(allHis):
#                if cmds.allHis[j]
        
        
        


