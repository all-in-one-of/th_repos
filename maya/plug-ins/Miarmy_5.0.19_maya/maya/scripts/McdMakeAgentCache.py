## +
## ===================================================================
## Copyright(C) 2010 - 2014 Basefount Software Limited.
## and/or its licensors.  All rights reserved.
##
## The coded instructions, statements, computer programs, and/or
## related material (collectively the "Data") in these files contain
## unpublished information proprietary to Basefount Technology
## Limitd. ("Basefount") and/or its licensors, which is
## protected by Chinese copyright law and by international treaties.
##
## The Data is provided for use exclusively by You. You have the right 
## to use, modify, and incorporate this Data into other products for 
## purposes authorized by the Basefount software license agreement, 
## without fee.
##
## The copyright notices in the Software and this entire statement, 
## including the above license grant, this restriction and the 
## following disclaimer, must be included in all copies of the 
## Software, in whole or in part, and all derivative works of 
## the Software, unless such copies or derivative works are solely 
## in the form of machine-executable object code generated by a 
## source language processor.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
## BASEFOUNT DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR
## IMPLIED WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES
## OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
## PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
## TRADE PRACTICE. IN NO EVENT WILL BASEFOUNT AND/OR ITS LICENSORS 
## BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
## DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF BASEFOUNTAIN 
## AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
## OR PROBABILITY OF SUCH DAMAGES.
##
## ===================================================================
## -

## +
## ===================================================================
##  Module Name: McdMakeAgentCache.py
##
##  Description:
##    Make cache
##
## ===================================================================

import maya.cmds as cmds
import maya.mel as mel
from McdGeneral import *
from McdMakeFootMap import *
import os
from McdPlacementFunctions import *


def McdMakeAgentCache():

    try:
        cmds.delete("McdFootLocatorGroup")
    except:
        pass

    performCachePreCheck()

    # batch make cache: --------------------------------------------------------
    startFrame = cmds.playbackOptions(q =True, min = True)
    endFrame = cmds.playbackOptions(q =True, max = True)
    
    stat = cmds.confirmDialog(t = "Agent Cache", m = "The agent cache information:\n" + \
                                            "Start Frame " + str(startFrame) + "\n" + \
                                            "End Frame: " + str(endFrame) + "\n" + \
                                            "If cache exist, new created cache will override the old one.", \
                                            b = ["Continue", "Cancel"])
    if stat == "Cancel":
        return
    
    globalNode = mel.eval("McdSimpleCommand -execute 2")
    
    isCallback = cmds.getAttr(globalNode + ".boolMaster[6]")
    if isCallback:
        executePreSim(globalNode)
    
    try:
        genFootLoc = cmds.getAttr(globalNode + ".genFootLoc")
    except:
        genFootLoc = 0
    
    brainNode = mel.eval("McdSimpleCommand -execute 3")
    solverFrame = cmds.getAttr(brainNode + ".startTime")
    solverFrame -= 1
    if solverFrame > startFrame:
        solverFrame = startFrame
    
    amount = 0
    counter = 0
    totalCount = endFrame - startFrame
    cmds.progressWindow( title = "Caching:", progress = 0, \
                      min = 0, max = 100, \
                      status = "caching", isInterruptable = True )
    
    # from solverFrame to endFrame:
    cmds.setAttr(globalNode + ".enableIDCM", 1)
    while(solverFrame <= endFrame):
        
        if isCallback:
            executePreFrame(globalNode)
        
        cmds.currentTime(solverFrame)
        
        if solverFrame >= startFrame:
            # deal with batch cache
            mel.eval("McdMakeCacheCmd;")
            
        if isCallback:
            executePostFrame(globalNode)
            
        if genFootLoc == 1:
            if counter == 0:
                CreateAndUpdateFootLoc(True)
            else:
                CreateAndUpdateFootLoc()
            
        solverFrame += 1
        
        ## progress operation: ////////////////////////////////////////////////
        if cmds.progressWindow( query = True, isCancelled = True ):
            cmds.setAttr(globalNode + ".enableIDCM", 0)
            break
        counter += 1
        amount = float(counter) / float(totalCount) * 100.0
        cmds.progressWindow( edit = True, progress = amount)
        
    cmds.progressWindow(endProgress=1)
    cmds.setAttr(globalNode + ".enableIDCM", 0)
    
    cmds.setAttr(globalNode + ".cacheVersion", 155)
    
    if isCallback:
        executePostSim(globalNode)
    
def performCachePreCheck():
    # agent exist
    allAgents = cmds.ls(type = "McdAgent")
    if allAgents == [] or allAgents == None:
        cmds.confirmDialog(t = "Auto abort", m = "There is no agent in scene for making cache.")
        raise Exception ("No agents in scene.")
        
    # path writable:
    globalNode = mel.eval("McdSimpleCommand -execute 2")
    rawPath = cmds.getAttr(globalNode + ".cacheFolder")
    
    cacheFolder = envPath2AbsPath(rawPath)
    
    if cacheFolder == "" or cacheFolder == None:
        cmds.confirmDialog(t = "Error", m = "The output folder is not exist. Specify it in Miarmy > Miarmy Global.")
        raise Exception("The output folder is not exist.")
        
    if not os.access(cacheFolder, os.W_OK):
        cmds.confirmDialog(t = "Error", m = "The output folder is not writable. Specify it in Miarmy > Miarmy Global")
        raise Exception("The output folder is not exist.")
    

def McdMergeAgentCache():

    allAgent = cmds.ls(type = "McdAgent")
    if not McdIsBlank(allAgent):
        cmds.confirmDialog(t = "Error", m = "Please deplace agents.")
        return;

    # batch make cache: --------------------------------------------------------
    startFrame = cmds.playbackOptions(q =True, min = True)
    endFrame = cmds.playbackOptions(q =True, max = True)
    
    stat = cmds.confirmDialog(t = "Merge Cache", m = "The agent cache information:\n" + \
                                            "Start Frame " + str(startFrame) + "\n" + \
                                            "End Frame: " + str(endFrame) + "\n" + \
                                            "If cache exist, new created cache will override the old one.", \
                                            b = ["Continue", "Cancel"])
    if stat == "Cancel":
        return
    
    globalNode = mel.eval("McdSimpleCommand -execute 2")
    
    brainNode = mel.eval("McdSimpleCommand -execute 3")
    solverFrame = cmds.getAttr(brainNode + ".startTime")
    solverFrame -= 1
    if solverFrame > startFrame:
        solverFrame = startFrame
    
    amount = 0
    counter = 0
    totalCount = endFrame - startFrame
    cmds.progressWindow( title = "Caching:", progress = 0, \
                      min = 0, max = 100, \
                      status = "caching", isInterruptable = True )
    
    # from solverFrame to endFrame:
    while(solverFrame <= endFrame):
        cmds.currentTime(solverFrame)
        
        if solverFrame >= startFrame:
            # deal with batch cache
            mel.eval("McdSimpleCommand -exe 29")
            
        solverFrame += 1
        
        ## progress operation: ////////////////////////////////////////////////
        if cmds.progressWindow( query = True, isCancelled = True ):
            break
        counter += 1
        amount = float(counter) / float(totalCount) * 100.0
        cmds.progressWindow( edit = True, progress = amount)
        
    cmds.progressWindow(endProgress=1)
    
    cmds.setAttr(globalNode + ".cacheVersion", 155)

    
    
def performLCachePreCheck(placeNames):
    
    # agent exist
    allAgents = cmds.ls(type = "McdAgent")
    if allAgents == [] or allAgents == None:
        cmds.confirmDialog(t = "Auto abort", m = "There is no agent in scene for making cache.")
        raise Exception ("No agents in scene.")
    
    for i in range(len(placeNames)):
        placeName = placeNames[i]
            
        # path writable:
        globalNode = McdGetMcdGlobalNode()
        rawPath = cmds.getAttr(globalNode + ".cacheFolder")
        
        cacheFolder = envPath2AbsPath(rawPath)
        
        subFolder = McdGetPlaceNodeNameForSubfolder(placeName)
        
        if cacheFolder == "" or cacheFolder == None:
            cmds.confirmDialog(t = "Error", m = "The output folder is not exist. Specify it in Miarmy > Miarmy Global.")
            raise Exception("The output folder is not exist.")
            
        if not os.access(cacheFolder, os.W_OK):
            cmds.confirmDialog(t = "Error", m = "The output folder is not writable. Specify it in Miarmy > Miarmy Global")
            raise Exception("The output folder is not exist.")
        
        cacheFolder += "/" + subFolder
        
        if not os.access(cacheFolder, os.R_OK):
            try:
                os.mkdir(cacheFolder)
            except:
                cmds.confirmDialog(t = "Error", m = "Cannot create output folder, maybe no priviledge")
                raise Exception("The output folder is cannot be created")


def McdGetPlaceNodeNameForSubfolder(placeName):
    
    colonStr = ":"
    treeStr = "|"
    dashStr = "-"
    
    nodeResultName = placeName
    
    if nodeResultName.find(colonStr) >= 0:
        outStrs1 = nodeResultName.split(colonStr)
        nbSeg = len(outStrs1);
        nodeResultName = outStrs1[nbSeg-1];
    
    
    if nodeResultName.find(treeStr) >= 0:
        outStrs2 = nodeResultName.split(treeStr)
        nbSeg = len(outStrs2);
        nodeResultName = ""
        for i in range (nbSeg):
            if i != nbSeg-1:
                nodeResultName += outStrs2[i] + dashStr;
            else:
                nodeResultName += outStrs2[i];

    return nodeResultName


# def McdMakeAgentLCache():
#     
#     selPlace = cmds.textScrollList("layercache_tsl", q = True, si = True)
#     if selPlace == []:
#         cmds.confirmDialog(t = "Agent Layer Cache", m = "Please select place node in list.")
#         return;
#     
#     
#     selPlace = cmds.textScrollList("layercache_tsl", q = True, si = True)[0]
#     if selPlace.find("*"):
#         selPlace = selPlace.split(" ")[-1]
#         
#     
#     performLCachePreCheck(selPlace)
# 
#     # batch make cache: --------------------------------------------------------
#     startFrame = cmds.playbackOptions(q =True, min = True)
#     endFrame = cmds.playbackOptions(q =True, max = True)
#     
#     stat = cmds.confirmDialog(t = "Agent Cache", m = "The layer agent cache information:\n" + \
#                                             "Start Frame " + str(startFrame) + "\n" + \
#                                             "End Frame: " + str(endFrame) + "\n" + \
#                                             "If cache exist, new created cache will override the old one.", \
#                                             b = ["Continue", "Cancel"])
#     if stat == "Cancel":
#         return
#     
#     globalNode = mel.eval("McdSimpleCommand -execute 2")
#     
#     isCallback = cmds.getAttr(globalNode + ".boolMaster[6]")
#     if isCallback:
#         executePreSim(globalNode)
#     
#     brainNode = mel.eval("McdSimpleCommand -execute 3")
#     solverFrame = cmds.getAttr(brainNode + ".startTime")
#     solverFrame -= 1
#     if solverFrame > startFrame:
#         solverFrame = startFrame
#     
#     amount = 0
#     counter = 0
#     totalCount = endFrame - startFrame
#     cmds.progressWindow( title = "Caching:", progress = 0, \
#                       min = 0, max = 100, \
#                       status = "caching", isInterruptable = True )
#     
#     # from solverFrame to endFrame:
#     cmds.setAttr(globalNode + ".enableIDCM", 1)
#     while(solverFrame <= endFrame):
#         
#         if isCallback:
#             executePreFrame(globalNode)
#         
#         cmds.currentTime(solverFrame)
#         
#         if solverFrame >= startFrame:
#             # deal with batch cache
#             cmds.setAttr(selPlace + ".makeCache", 1)
#             mel.eval("McdMakeCacheCmd;")
#             
#         if isCallback:
#             executePostFrame(globalNode)
#             
#         solverFrame += 1
#         
#         ## progress operation: ////////////////////////////////////////////////
#         if cmds.progressWindow( query = True, isCancelled = True ):
#             cmds.setAttr(globalNode + ".enableIDCM", 0)
#             break
#         counter += 1
#         amount = float(counter) / float(totalCount) * 100.0
#         cmds.progressWindow( edit = True, progress = amount)
#         
#     cmds.progressWindow(endProgress=1)
#     cmds.setAttr(globalNode + ".enableIDCM", 0)
#     
#     cmds.setAttr(globalNode + ".cacheVersion", 155)
#     
#     if isCallback:
#         executePostSim(globalNode)




def McdMakeAgentLCache():
    
    selPlace = cmds.textScrollList("layercache_tsl", q = True, si = True)
    if selPlace == []:
        cmds.confirmDialog(t = "Agent Layer Cache", m = "Please select place node in list.")
        return;
    
    
    selPlaces = cmds.textScrollList("layercache_tsl", q = True, si = True)
    for i in range(len(selPlaces)):
        selPlaces[i] = selPlaces[i].split(" ")[-1]
        
    
    performLCachePreCheck(selPlaces)

    # batch make cache: --------------------------------------------------------
    startFrame = cmds.playbackOptions(q =True, min = True)
    endFrame = cmds.playbackOptions(q =True, max = True)
    
    stat = cmds.confirmDialog(t = "Agent Cache", m = "The layer agent cache information:\n" + \
                                            "Start Frame " + str(startFrame) + "\n" + \
                                            "End Frame: " + str(endFrame) + "\n" + \
                                            "If cache exist, new created cache will override the old one.", \
                                            b = ["Continue", "Cancel"])
    if stat == "Cancel":
        return
    
    globalNode = McdGetMcdGlobalNode()
    
    isCallback = cmds.getAttr(globalNode + ".boolMaster[6]")
    if isCallback:
        executePreSim(globalNode)
    
    brainNode = mel.eval("McdSimpleCommand -execute 3")
    solverFrame = cmds.getAttr(brainNode + ".startTime")
    solverFrame -= 1
    if solverFrame > startFrame:
        solverFrame = startFrame
    
    amount = 0
    counter = 0
    totalCount = endFrame - startFrame
    cmds.progressWindow( title = "Caching:", progress = 0, \
                      min = 0, max = 100, \
                      status = "caching", isInterruptable = True )
    
    # from solverFrame to endFrame:
    cmds.setAttr(globalNode + ".enableIDCM", 1)
    while(solverFrame <= endFrame):
        
        if isCallback:
            executePreFrame(globalNode)
        
        cmds.currentTime(solverFrame)
        
        if solverFrame >= startFrame:
            # deal with batch cache
            for i in range(len(selPlaces)):
                cmds.setAttr(selPlaces[i] + ".makeCache", 1)
            
            mel.eval("McdMakeCacheCmd;")
            
        if isCallback:
            executePostFrame(globalNode)
            
        solverFrame += 1
        
        ## progress operation: ////////////////////////////////////////////////
        if cmds.progressWindow( query = True, isCancelled = True ):
            cmds.setAttr(globalNode + ".enableIDCM", 0)
            break
        counter += 1
        amount = float(counter) / float(totalCount) * 100.0
        cmds.progressWindow( edit = True, progress = amount)
        
    cmds.progressWindow(endProgress=1)
    cmds.setAttr(globalNode + ".enableIDCM", 0)
    
    cmds.setAttr(globalNode + ".cacheVersion", 155)
    
    if isCallback:
        executePostSim(globalNode)











